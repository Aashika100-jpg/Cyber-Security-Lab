# -*- coding: utf-8 -*-
"""DIGITALSIGNATURE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TMC8zegkK53mnm5tXeIywOWJRXyAzBR7
"""

import hashlib
import random
from math import gcd

# --------------------------------------------------
# 1. Helper Functions
# --------------------------------------------------

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    gcd_val, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd_val, x, y

def mod_inverse(e, phi):
    gcd_val, x, _ = extended_gcd(e, phi)
    if gcd_val != 1:
        raise Exception("Modular inverse does not exist")
    return x % phi

# --------------------------------------------------
# 2. USER INPUT p AND q
# --------------------------------------------------

p = int(input("Enter prime number p: "))
q = int(input("Enter prime number q: "))

if not is_prime(p) or not is_prime(q):
    raise ValueError("Both p and q must be prime numbers")

if p == q:
    raise ValueError("p and q must be different")

# --------------------------------------------------
# 3. RSA KEY GENERATION
# --------------------------------------------------

n = p * q
phi_n = (p - 1) * (q - 1)

e = random.randint(2, phi_n - 1)
while gcd(e, phi_n) != 1:
    e = random.randint(2, phi_n - 1)

d = mod_inverse(e, phi_n)

print("\nCalculated Values:")
print("n =", n)
print("Î¦(n) =", phi_n)
print("Public Key (e, n):", (e, n))
print("Private Key (d, n):", (d, n))

# --------------------------------------------------
# 4. DIGITAL SIGNATURE
# --------------------------------------------------

def sign_message(message):
    h = int.from_bytes(hashlib.sha256(message.encode()).digest(), 'big')
    return pow(h, d, n)

def verify_signature(message, signature):
    h = int.from_bytes(hashlib.sha256(message.encode()).digest(), 'big')
    return pow(signature, e, n) == h % n

# --------------------------------------------------
# 5. EXAMPLE
# --------------------------------------------------

message = "RSA Digital Signature using Hash Function"
signature = sign_message(message)

print("\nDigital Signature:", signature)
print("Signature Valid:", verify_signature(message, signature))